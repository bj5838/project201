//This will contain the implementations of
//the functions whose prototypes are in ll.h
//NOTE: best practice is to name the header file
//the same as the source file, but there's no enforcement
#include <stdio.h>
#include <stdlib.h> //Contains the definition of malloc
#include <string.h>
#include "LinkedList.h"
#include "hash.h"
#include <winsock2.h>

void initialize(struct LinkedList* list) {
	//IF we passed in struct LinkedList list instead	
	list->size = 0;		//list.size = 0;
	list->head = NULL;  //list.head = NULL;
}

void addItem(struct LinkedList* list, char* cmd) {
	
	struct node* newNode = (struct node*)malloc(sizeof(struct node));

	
	strcpy(newNode->command, cmd);

	newNode->next = list->head;
	if (newNode->next != NULL) { newNode->hash = hashfunc(newNode->next->command, newNode->next->hash); }
	else { newNode->hash = hashfunc(NULL, NULL); };

	list->head = newNode;
	
	list->size++;
}

void alterNode(struct LinkedList* listToAlter, int nodenum) {
	struct node* temp = listToAlter->head;
	if (nodenum > listToAlter->size - 1) nodenum = listToAlter->size - 1;
	for (int i = 0; i < nodenum; i++) {
		temp = temp->next;
	}
	strcpy(temp->command, "ALTERED");
}

int validate(struct LinkedList* listToValidate, SOCKET* clientSock) {
	struct node* temp = listToValidate->head; //find the head of the list
	unsigned char* tempHash;
	char error[1000] = "";
	int bytesWritten = 0;
	SOCKET clientConn = *clientSock;

	if (temp == NULL) {
		return 1;
	}
	while (temp->next != NULL){
		tempHash = hashfunc(temp->next->command, temp->next->hash);
		if (!compareHashes(temp->hash, tempHash)) {
			
			//printf("ERROR> Alteration detected in the following node\n");
			bytesWritten=sprintf(error, "ERROR > Alteration detected in the following node\n");
			//printf("VALIDATETEMP-ERROR: %s\n", error);
			
			//printf("NodeAddr: %p\t", temp->next);
			bytesWritten += sprintf(&(error[bytesWritten]), "NodeAddr: %p\t", temp->next);
			//printf("VALIDATETEMP-ERROR: %s\n", error);

			//printf("Hash: ");
			bytesWritten += sprintf(&(error[bytesWritten]), "Hash: %02x %02x %02x %02x %02x\t", temp->next->hash[0], temp->next->hash[1], temp->next->hash[2], temp->next->hash[3], temp->next->hash[4]);
			//printHash(temp->next->hash);
			//printf("VALIDATETEMP-ERROR: %s\n", error);

			if (temp->next->next != NULL) { 
				//printf("Next: %p\t", temp->next->next);
				bytesWritten += sprintf(&(error[bytesWritten]), "Next: %p\t", temp->next->next);
				//printf("VALIDATETEMP-ERROR: %s\n", error);
			}
			else { 
				//printf("Next: NULL\t");
				bytesWritten += sprintf(&(error[bytesWritten]), "Next: NULL\t");
				//printf("VALIDATETEMP-ERROR: %s\n", error);
			}
			//printf("Command: %s\n", temp->next->command);
			bytesWritten += sprintf(&(error[bytesWritten]), "Command: %s\n", temp->next->command);
			//printf("VALIDATETEMP-ERROR: %s\n", error);
			send(clientConn, error, strlen(error), 0);
			return 0;
		}
		temp = temp->next;
	}

	return 1;
}

void printList(struct LinkedList* listToPrint, SOCKET* clientSock) {
//void printList(struct LinkedList* listToPrint) {
	struct node* temp = listToPrint->head;
	int bytesWritten = 0;
	char printedList[5000]="";
	SOCKET clientConn = *clientSock;
	if (temp == NULL) {
		//printf("History is empty\n");
		bytesWritten = sprintf(printedList, "History is empty\n");
		send(clientConn, printedList, strlen(printedList), 0);
	}
	else {
		//printf("------\n");
		bytesWritten = sprintf(printedList, "------\n");
		//printf("BW: %d, HISTORYTEMP-PRINTEDLIST: %s\n", bytesWritten, printedList);
		while (temp != NULL) {
			/*printf("NodeAddr: %p\t", temp);
			printf("Hash: ");
			printHash(temp->hash);
			printf("\t");
			if (temp->next != NULL) { printf("Next: %p\t", temp->next); }
			else { printf("Next: NULL\t"); }
			printf("Command: %s\n", temp->command);*/

			//printf("NodeAddr: %p\t", temp);
			bytesWritten += sprintf(&(printedList[bytesWritten]), "NodeAddr: %p\t", temp);
			//printf("BW: %d, HISTORYTEMP-PRINTEDLIST: %s\n", bytesWritten, printedList);

			//printf("Hash: ");
			bytesWritten += sprintf(&(printedList[bytesWritten]), "Hash: % 02x % 02x % 02x % 02x % 02x\t", temp->hash[0], temp->hash[1], temp->hash[2], temp->hash[3], temp->hash[4]);
			//printf("BW: %d, HISTORYTEMP-PRINTEDLIST: %s\n", bytesWritten, printedList);
			//printHash(temp->next->hash);
			
			if (temp->next != NULL) {
				//printf("Next: %p\t", temp->next);
				bytesWritten += sprintf(&(printedList[bytesWritten]), "Next: %p\t", temp->next);
				//printf("BW: %d, HISTORYTEMP-PRINTEDLIST: %s\n", bytesWritten, printedList);
			}
			else {
				//printf("Next: NULL\t");
				bytesWritten += sprintf(&(printedList[bytesWritten]), "Next: NULL\t");
				//printf("BW: %d, HISTORYTEMP-PRINTEDLIST: %s\n", bytesWritten, printedList);
			}
			//printf("Command: %s\n", temp->command);
			bytesWritten += sprintf(&(printedList[bytesWritten]), "Command: %s\n", temp->command);
			//printf("BW: %d, HISTORYTEMP-PRINTEDLIST: %s\n", bytesWritten, printedList);

			temp = temp->next;
		}
		//printf("NULL\n");
		bytesWritten += sprintf(&(printedList[bytesWritten]), "NULL\n");
		//printf("BW: %d, HISTORYTEMP-PRINTEDLIST: %s\n", bytesWritten, printedList);
		//printf("------\n");
		bytesWritten += sprintf(&(printedList[bytesWritten]), "------\n");
		//printf("BW: %d, HISTORYTEMP-PRINTEDLIST: %s\n", bytesWritten, printedList);
	}
	if (validate(listToPrint, clientSock)) {
		//printf("Command history integrity validated\n");
		bytesWritten += sprintf(&(printedList[bytesWritten]), "Command history integrity validated\n");
		send(clientConn, printedList, strlen(printedList), 0);
	}

	
}
