#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <process.h>
#include <winsock2.h>
#include <time.h>
#include "LinkedList.h"
#include "parse.h"
#include "server.h"

#pragma comment(lib, "ws2_32.lib")

int __stdcall HandleConnection(struct threadArgs* args) {

	SOCKET clientConn = *(args->clientConn);
	struct LinkedList* CommandHistory = args->CommandHistory;
	int shouldAlterWork = 1;
	int alterProbability = 20;
	int nodeToAlter;
	int bytesRead;
	char* rawCommand;
	
	char banner[] = "WELCOME TO FML SERVER!\n";
	char prompt[] = "CMD> ";
	char errorTwoArgs[] = "ERROR> command takes 2 arguments\n";
	char errorFirstArg[] = "ERROR> 1st arg must be 'local' or 'remote'\n";
	char errorSecondArg[] = "ERROR> 2nd argument must be 'files', 'path', or 'folders'\n";
	char errorNoArgs[] = "ERROR> command takes no arguments\n";
	char errorInvalidCommand[] = "ERROR> Invalid command\n";
	char invalidCharacter[] = "Error> Invalid character detected\n";
	char errorOther[] = "ERROR> OTHER\n";

	int parseResult;
	rawCommand = (char*)malloc(sizeof(char) * 1000);

	send(clientConn, banner, sizeof(banner), 0);
	while (1) {
		printf("Sending prompt\n");
		send(clientConn, prompt, sizeof(prompt), 0);
		printf("Waiting on command:\n");
		
		bytesRead = recv(clientConn, rawCommand, 1000, 0);
		if (bytesRead == -1) break;
		rawCommand[bytesRead] = '\0';
		printf("Received command: %s\n", rawCommand);
	
		parseResult = parseCommand(rawCommand, CommandHistory, &clientConn);
		if (parseResult==1) {
			addItem(CommandHistory, rawCommand);
			printf("%s added to history\n", rawCommand);
			if (shouldAlterWork && CommandHistory->size != 1 && rand() % 100 + 1 < alterProbability) {
				alterNode(CommandHistory, rand() % 10);
				printf("Alteration!\n");
			}
		}
		else if (parseResult == 0) {
			printf("Terminating Connection\n");
			break;
		}
		else if (parseResult == -1) {
			printf("Sending TwoArgs Error\n");
			send(clientConn, errorTwoArgs, sizeof(errorTwoArgs), 0);
		}
		else if (parseResult == -2) {
			printf("Sending FirstArgs Error\n");
			 send(clientConn, errorFirstArg, sizeof(errorFirstArg), 0); 
		}
		else if (parseResult == -3) {
			printf("Sending SecondArgs Error\n");
			send(clientConn, errorSecondArg, sizeof(errorSecondArg), 0); 
		}
		else if (parseResult == -4) {
			printf("Sending NoArgs Error\n");
			send(clientConn, errorNoArgs, sizeof(errorNoArgs), 0);
		}
		else if (parseResult == -5) {
			printf("Sending Invalid Command Error\n");
			send(clientConn, errorInvalidCommand, sizeof(errorInvalidCommand), 0);
		}
		else if (parseResult == -6) {
			printf("Sending Invalid Character Error\n");
			send(clientConn, errorInvalidCommand, sizeof(errorInvalidCommand), 0);
		}
		else {
			send(clientConn, errorOther, sizeof(errorOther), 0);
		}
		
	}
	free(rawCommand);
	closesocket(&clientConn);
	_endthreadex(0);
	return 0;
}

void BeginServer() {
	WSADATA winSockData; 
	SOCKET serverSocket, clientSocket;
	struct sockaddr_in serverAddress, clientAddress;
	int addrLen = sizeof(clientAddress);
	HANDLE thread;
	int result;
	int port = 8421;

	struct LinkedList* CommandHistory = (struct LinkedList*)malloc(sizeof(struct LinkedList));
	initialize(CommandHistory);
	srand(time(NULL));
	int threadnum = 0;

	result = WSAStartup(MAKEWORD(2, 2), &winSockData);
	if (result != 0) {
		printf("Failed to initialize WinSock\n");
		exit(-1);
	}

	
	serverSocket = socket(AF_INET, SOCK_STREAM, 0);
	serverAddress.sin_family = AF_INET;	
	serverAddress.sin_addr.s_addr = INADDR_ANY;
	serverAddress.sin_port = htons(port);


	bind(serverSocket, (struct sockaddr*)&serverAddress, sizeof(serverAddress));
	listen(serverSocket, 5);
	while (1) {
		clientSocket = accept(serverSocket, &clientAddress, &addrLen);
		
		struct threadArgs* args = (struct threadArgs*)malloc(sizeof(struct threadArgs));
		args->clientConn = &clientSocket;
		args->CommandHistory = CommandHistory;
		threadnum++;
		printf("Connection #%d established\n", threadnum);
		thread = _beginthreadex(NULL, 0, &HandleConnection, args, 0, &threadnum);
	}
	
}
